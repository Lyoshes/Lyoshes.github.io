<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Ring Tetris MVP</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#0b0f14; overflow:hidden; touch-action:none; }
    canvas { display:block; width:100%; height:100%; }
    .hint { position:fixed; left:10px; bottom:10px; color:#9fb2c7; font:12px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial; opacity:.85; }
    .hud  { position:fixed; left:10px; top:10px; color:#cfe0f3; font:12px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial; opacity:.9; }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hud" id="hud"></div>
<div class="hint">Свайп влево/вправо: вращение цилиндра с инерцией. Фигура падает строго по центру; цилиндр «подставляет» сектор.</div>
<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const TAU = Math.PI * 2;

  // ===== Game params =====
  const N = 30;   // sectors around ring
  const H = 24;   // height in rows (0 bottom)
  const ANG_OFFSET = Math.PI / 2; // "front" is the bottom point (closest to user)

  // ===== Grid =====
  // grid[y][s] : 0 empty, 1 filled
  const grid = Array.from({length: H}, () => new Uint8Array(N));

  // ===== Pieces (MVP: single + bar2) =====
  const PIECES = [
    { name:'single', cells:[{x:0,y:0}] },
    { name:'bar2',   cells:[{x:0,y:0},{x:1,y:0}] },
  ];

  // Active falling piece state (falls in screen-space center)
  let activePiece = null;
  let pieceY = H + 3;       // float (grid coords), decreases to 0
  let fallTimer = 0;
  let fallInterval = 0.7;   // seconds per row

  // ===== Killzone (visual only for now) =====
  let killLevel = 0;
  let killRate  = 0.18;     // rows per second

  // ===== Rotation (cylinder) =====
  let rotFloat  = 0;        // continuous sectors
  let targetRot = 0;
  let rotVel    = 0;        // sectors/sec

  const DAMP = 9.0;         // velocity damping
  const SPRING = 35.0;      // pull to target

  // ===== Input (swipe) =====
  let dragging = false;
  let lastX = 0;
  let lastT = 0;

  canvas.addEventListener('pointerdown', (e) => {
    dragging = true;
    lastX = e.clientX;
    lastT = performance.now();
    canvas.setPointerCapture(e.pointerId);
  });

  canvas.addEventListener('pointermove', (e) => {
    if (!dragging) return;
    const now = performance.now();
    const dx = e.clientX - lastX;
    const dt = Math.max(0.001, (now - lastT) / 1000);

    // map pixels to sectors: 1 sector per ~60 px (tune)
    const deltaS = dx / 60;
    targetRot -= deltaS;

    // inertia estimate
    rotVel = (-deltaS / dt) * 0.35;

    lastX = e.clientX;
    lastT = now;
  });

  canvas.addEventListener('pointerup', (e) => {
    dragging = false;
    canvas.releasePointerCapture(e.pointerId);
  });

  function normSector(s) {
    s %= N;
    if (s < 0) s += N;
    return s;
  }

  function snappedRot() {
    return normSector(Math.round(rotFloat));
  }

  // ===== Spawn / collision / lock =====
  function spawnPiece() {
    activePiece = PIECES[(Math.random() * PIECES.length) | 0];
    // start above top
    pieceY = H + 3;
    fallTimer = 0;
  }

  function canPlaceAt(y) {
    if (!activePiece) return false;
    const s0 = snappedRot(); // IMPORTANT: cylinder decides landing sector
    for (const c of activePiece.cells) {
      const cy = y + c.y;
      const cs = normSector(s0 + c.x);
      if (cy < 0) return false;
      if (cy >= H) continue; // above field is ok
      if (grid[cy][cs]) return false;
    }
    return true;
  }

  function lockPiece() {
    if (!activePiece) return;

    // ===== CRITICAL FIX 1: snap rotation BEFORE writing to grid =====
    const s0 = snappedRot();
    rotFloat = s0;
    targetRot = s0;
    rotVel = 0;

    // write cells
    for (const c of activePiece.cells) {
      const cy = Math.floor(pieceY) + c.y;
      const cs = normSector(s0 + c.x);
      if (cy >= 0 && cy < H) grid[cy][cs] = 1;
    }

    clearRings();

    // If piece locked above visible area -> reset (simple MVP)
    // Spawn next
    spawnPiece();
  }

  function clearRings() {
    for (let y = 0; y < H; y++) {
      let full = true;
      for (let s = 0; s < N; s++) {
        if (!grid[y][s]) { full = false; break; }
      }
      if (!full) continue;

      // drop everything above down
      for (let yy = y; yy < H - 1; yy++) {
        grid[yy].set(grid[yy + 1]);
      }
      grid[H - 1].fill(0);

      y--; // re-check same row

      // reward: push back killzone a bit
      killLevel = Math.max(0, killLevel - 1.0);
    }
  }

  function tryMoveDown() {
    const nextY = Math.floor(pieceY) - 1;
    if (canPlaceAt(nextY)) {
      pieceY = nextY;
    } else {
      lockPiece();
    }
  }

  // ===== Rendering helpers =====
  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const w = Math.floor(canvas.clientWidth * dpr);
    const h = Math.floor(canvas.clientHeight * dpr);
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
      ctx.setTransform(dpr,0,0,dpr,0,0); // keep coordinates in CSS pixels
    }
  }

  function levelYToScreenY(topY, towerHeightPx, y) {
    // y=0 bottom, y=H top
    const t = 1 - (y / H);
    return topY + t * towerHeightPx;
  }

  function sectorCenterXY(centerX, yScreen, radiusX, radiusY, s, rot) {
    const ang = ((s - rot) / N) * TAU + ANG_OFFSET;
    return {
      x: centerX + Math.cos(ang) * radiusX,
      y: yScreen + Math.sin(ang) * radiusY,
      ang,
    };
  }

  function drawOrientedBlock(px, py, tx, ty, w, h, fillStyle, alpha=1) {
    ctx.save();
    ctx.translate(px, py);
    const a = Math.atan2(ty, tx);
    ctx.rotate(a);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = fillStyle;
    ctx.fillRect(-w/2, -h/2, w, h);
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function draw() {
    resize();
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    ctx.clearRect(0,0,w,h);

    // Background
    ctx.fillStyle = '#0b0f14';
    ctx.fillRect(0,0,w,h);

    // Layout cylinder
    const centerX = w * 0.5;
    const topY = h * 0.10;
    const bottomY = h * 0.92;
    const towerHeightPx = bottomY - topY;

    const radiusX = Math.min(w * 0.38, 260);
    const radiusY = radiusX * 0.28;

    // Water / killzone
    const killY = levelYToScreenY(topY, towerHeightPx, killLevel);
    ctx.fillStyle = 'rgba(28,72,120,0.42)';
    ctx.fillRect(0, killY, w, h - killY);

    // Rings (level ellipses)
    ctx.strokeStyle = 'rgba(160,190,220,0.25)';
    ctx.lineWidth = 1;
    for (let y=0; y<=H; y++) {
      const py = levelYToScreenY(topY, towerHeightPx, y);
      ctx.beginPath();
      ctx.ellipse(centerX, py, radiusX, radiusY, 0, 0, TAU);
      ctx.stroke();
    }

    // Center drop-line (visual)
    ctx.strokeStyle = 'rgba(255,220,140,0.55)';
    ctx.beginPath();
    ctx.moveTo(centerX, topY);
    ctx.lineTo(centerX, bottomY);
    ctx.stroke();

    // ===== Fixed blocks =====
    // draw back-to-front by painter's algorithm: use sin(angle) as depth proxy
    const blocks = [];
    for (let y=0; y<H; y++) {
      const yScr = levelYToScreenY(topY, towerHeightPx, y + 0.5);
      for (let s=0; s<N; s++) {
        if (!grid[y][s]) continue;
        const p = sectorCenterXY(centerX, yScr, radiusX, radiusY, s, rotFloat);
        blocks.push({y, s, yScr, p});
      }
    }
    blocks.sort((a,b) => (a.p.y - b.p.y)); // farther (top) first, closer (bottom) last

    for (const b of blocks) {
      const p0 = b.p;
      // neighbor points to estimate tangent and width
      const p1 = sectorCenterXY(centerX, b.yScr, radiusX, radiusY, b.s+1, rotFloat);
      const p_1 = sectorCenterXY(centerX, b.yScr, radiusX, radiusY, b.s-1, rotFloat);
      const tx = (p1.x - p_1.x);
      const ty = (p1.y - p_1.y);
      const arcDist = Math.hypot(p1.x - p0.x, p1.y - p0.y);

      // ===== CRITICAL FIX 2: exact-ish sector width + tiny overlap =====
      const bw = arcDist * 1.06; // overlap kills anti-alias seams
      const bh = (towerHeightPx / H) * 0.90;

      drawOrientedBlock(p0.x, p0.y, tx, ty, bw, bh, 'rgba(235,240,250,0.55)', 1);
    }

    // ===== Active falling piece (ALWAYS in screen center, no rotation with cylinder) =====
    if (activePiece) {
      const yScr = levelYToScreenY(topY, towerHeightPx, pieceY + 0.5);

      // determine block width at "front" (bottom point) at this height:
      // take the currently front sector s0 (snapped) and compute arc distance to neighbor
      const s0 = snappedRot();
      const p0 = sectorCenterXY(centerX, yScr, radiusX, radiusY, s0, rotFloat);
      const p1 = sectorCenterXY(centerX, yScr, radiusX, radiusY, s0+1, rotFloat);
      const arcDist = Math.hypot(p1.x - p0.x, p1.y - p0.y);
      const bw = arcDist * 1.06;
      const bh = (towerHeightPx / H) * 0.90;

      // Draw blocks with pivot block at exact centerX
      // (x offsets use integer dx, so bar2 appears to the right of pivot – that's OK for MVP)
      for (const c of activePiece.cells) {
        const x = centerX + c.x * bw;
        const y = levelYToScreenY(topY, towerHeightPx, (pieceY + c.y) + 0.5);
        ctx.fillStyle = 'rgba(255,170,180,0.75)';
        ctx.fillRect(x - bw/2, y - bh/2, bw, bh);
      }
    }

    // HUD
    document.getElementById('hud').textContent =
      `N=${N} H=${H} rot=${rotFloat.toFixed(2)} (snap=${snappedRot()})  kill=${killLevel.toFixed(1)}/${H}`;
  }

  // ===== Main loop =====
  let last = performance.now();
  function tick(now) {
    const dt = Math.min(0.05, Math.max(0.001, (now - last) / 1000));
    last = now;

    // killzone
    killLevel += killRate * dt;
    if (killLevel >= H) {
      // simple reset
      for (let y=0; y<H; y++) grid[y].fill(0);
      killLevel = 0;
      rotFloat = targetRot = 0;
      rotVel = 0;
      spawnPiece();
    }

    // rotation spring + damping (only when not actively dragging)
    if (!dragging) {
      const diff = (targetRot - rotFloat);
      rotVel += diff * SPRING * dt;
      rotVel *= Math.exp(-DAMP * dt);
      rotFloat += rotVel * dt;
    } else {
      rotFloat += rotVel * dt;
      rotVel *= Math.exp(-DAMP * dt);
    }

    // keep rotFloat bounded to avoid float growth
    if (rotFloat >  1e6) rotFloat %= N;
    if (rotFloat < -1e6) rotFloat %= N;

    // falling
    fallTimer += dt;
    if (fallTimer >= fallInterval) {
      fallTimer -= fallInterval;
      tryMoveDown();
    }

    draw();
    requestAnimationFrame(tick);
  }

  spawnPiece();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
