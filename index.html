<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Ring Tetris MVP</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#0b0f14; overflow:hidden; touch-action:none; }
    canvas { display:block; width:100%; height:100%; }
    .hud {
      position:fixed; left:12px; top:10px; right:12px;
      color:#e6edf3; font:14px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Arial;
      display:flex; justify-content:space-between; gap:12px; pointer-events:none;
      text-shadow: 0 1px 2px rgba(0,0,0,.5);
    }
    .hint {
      position:fixed; left:12px; bottom:12px; right:12px;
      color:#9fb0c2; font:12px/1.3 system-ui,-apple-system,Segoe UI,Roboto,Arial;
      opacity:.9; pointer-events:none;
    }
  </style>
</head>
<body>
  <div class="hud">
    <div id="leftHud">N=30 H=24</div>
    <div id="rightHud"></div>
  </div>
  <div class="hint">Свайп влево/вправо: вращение цилиндра с инерцией и “трещёткой”.</div>
  <canvas id="c"></canvas>

<script>
(() => {
  // ===== Config =====
  const N = 30;       // sectors
  const H = 24;       // visible height (levels)
  const pixelsPerSectorFactor = 6; // smaller => faster rotation per swipe
  const friction = 8.0;          // bigger => stronger damping
  const snapStrength = 18.0;     // bigger => stronger snap
  const snapVelThreshold = 0.6;  // sectors/sec
  const snapEps = 0.002;         // sectors
  const killRate = 0.35;         // levels/sec (tune)
  const killReward = 2.0;        // levels to push back on ring clear (future)

  // ===== Canvas =====
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d', { alpha: false });

  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    canvas.width = Math.floor(canvas.clientWidth * dpr);
    canvas.height = Math.floor(canvas.clientHeight * dpr);
    ctx.setTransform(dpr,0,0,dpr,0,0);
  }
  window.addEventListener('resize', resize);
  resize();

  // ===== Grid =====
  // 0 empty, 1 filled. y=0 is the bottom row.
  const grid = Array.from({length: H}, () => new Uint8Array(N));

  // ===== Piece definitions =====
  // Piece definitions
  // Each entry defines a piece by its name and an array of rotation states.  Each rotation
  // state is a list of cell offsets relative to a pivot at (0,0).  The offsets are in
  // sector (x) and vertical (y) coordinates.  Negative x values mean the cell lies to
  // the left of the pivot; positive values lie to the right.  Negative y values are
  // above the pivot; positive values are below.
  //
  // For this MVP we include a handful of simple shapes that span multiple sectors to
  // demonstrate how cubes can wrap around the ring.  Additional shapes can easily be
  // added later.  If you don't want a particular shape, remove its entry from the
  // PIECES array.
  const PIECES = [
    {
      name: 'single',
      rotations: [
        // just one block
        [{x: 0, y: 0}],
      ],
    },
    {
      name: 'bar2',
      rotations: [
        // two horizontally adjacent blocks
        [{x: 0, y: 0}, {x: 1, y: 0}],
      ],
    },
    {
      name: 'bar3',
      rotations: [
        // three horizontally adjacent blocks
        [{x: -1, y: 0}, {x: 0, y: 0}, {x: 1, y: 0}],
      ],
    },
    {
      name: 'bar4',
      rotations: [
        // four horizontally adjacent blocks
        [{x: -1, y: 0}, {x: 0, y: 0}, {x: 1, y: 0}, {x: 2, y: 0}],
      ],
    },
    {
      name: 'square',
      rotations: [
        // 2x2 square (two sectors wide, two rows high)
        [{x: 0, y: 0}, {x: 1, y: 0}, {x: 0, y: 1}, {x: 1, y: 1}],
      ],
    },
    {
      name: 'L',
      rotations: [
        // simple L shape: two in a row plus one above the pivot
        [{x: 0, y: 0}, {x: 1, y: 0}, {x: 0, y: 1}],
      ],
    },
  ];

  // Active falling piece state
  let activePiece = null;      // the current piece object from PIECES
  let pieceRotIndex = 0;       // which rotation state is active
  let pieceY = 0;              // integer y coordinate of the piece pivot
  let fallTimer = 0;           // accumulates time until the piece moves down one cell
  const fallInterval = 0.7;    // seconds per drop (adjust for difficulty)

  // Spawn a new piece above the top of the visible area.
  function spawnPiece() {
    const index = Math.floor(Math.random() * PIECES.length);
    activePiece = PIECES[index];
    pieceRotIndex = 0;
    // Position the pivot above the top of the grid so the entire shape starts
    // outside the visible playfield.  We add a buffer so even tall pieces with
    // positive y offsets spawn out of view.  Feel free to adjust the buffer
    // value to change how far above the field new pieces appear.
    const bufferRows = 3;
    pieceY = H + bufferRows;
  }

  // Determine whether the active piece can occupy a given y position.
  function canPlaceAt(y, rotIndex = pieceRotIndex) {
    if (!activePiece) return false;
    const cells = activePiece.rotations[rotIndex];
    const s0 = getRotIndex();
    for (const cell of cells) {
      const cy = y + cell.y;
      const cs = normSector(s0 + cell.x);
      // If the cell is below the bottom of the field, it's a collision.
      if (cy < 0) return false;
      // Ignore cells above the top – they simply haven't entered the field yet.
      if (cy >= H) continue;
      if (grid[cy][cs]) return false;
    }
    return true;
  }

  // Lock the current piece into the grid at its current position,
  // clear any complete rings, and spawn a new piece.
  function lockPiece() {
    if (!activePiece) return;
    const cells = activePiece.rotations[pieceRotIndex];
    const s0 = getRotIndex();
    for (const cell of cells) {
      const cy = pieceY + cell.y;
      const cs = normSector(s0 + cell.x);
      if (cy >= 0 && cy < H) {
        grid[cy][cs] = 1;
      }
    }
    clearRings();
    spawnPiece();
  }

  // Attempt to move the active piece down by one row. If it can't move,
  // lock it and spawn a new one.
  function tryMoveDown() {
    if (canPlaceAt(pieceY - 1)) {
      pieceY -= 1;
    } else {
      lockPiece();
    }
  }

  // Remove any fully occupied rings and shift everything above them down.
  function clearRings() {
    let cleared = 0;
    for (let y = 0; y < H; y++) {
      let full = true;
      for (let s = 0; s < N; s++) {
        if (!grid[y][s]) {
          full = false;
          break;
        }
      }
      if (full) {
        // Remove this ring and insert an empty ring at the top.
        grid.splice(y, 1);
        grid.push(new Uint8Array(N));
        y--; // recheck the new row at this index
        cleared++;
      }
    }
    if (cleared > 0) {
      // Reward: lower the kill zone for each cleared ring.
      killLevel = Math.max(0, killLevel - killReward * cleared);
    }
  }

  // ===== Rotation with inertia + ratchet =====
  let rotFloat = 0; // in sectors
  let rotVel = 0;   // sectors/sec
  let dragging = false;
  let dragStartX = 0;
  let dragStartRot = 0;
  let lastMoveT = 0;
  let lastMoveX = 0;
  let killLevel = 0; // levels from bottom, grows upward (float)

  const leftHud = document.getElementById('leftHud');
  const rightHud = document.getElementById('rightHud');

  function normSector(i) {
    let x = i % N;
    if (x < 0) x += N;
    return x;
  }

  function getRotIndex() {
    return normSector(Math.round(rotFloat));
  }

  function onPointerDown(e) {
    dragging = true;
    const x = e.clientX ?? (e.touches && e.touches[0]?.clientX) ?? 0;
    dragStartX = x;
    dragStartRot = rotFloat;
    rotVel = 0;
    lastMoveT = performance.now();
    lastMoveX = x;
  }

  function onPointerMove(e) {
    if (!dragging) return;
    const x = e.clientX ?? (e.touches && e.touches[0]?.clientX) ?? 0;

    const w = canvas.clientWidth || 1;
    const pixelsPerSector = w / pixelsPerSectorFactor;

    const dx = x - dragStartX;
    rotFloat = dragStartRot + (-dx / pixelsPerSector);

    // estimate velocity
    const now = performance.now();
    const dt = Math.max(1, now - lastMoveT) / 1000;
    const vx = (x - lastMoveX) / dt; // px/sec
    rotVel = -(vx / pixelsPerSector); // sectors/sec

    lastMoveT = now;
    lastMoveX = x;
  }

  function onPointerUp() {
    dragging = false;
  }

  // use pointer events when available
  canvas.addEventListener('pointerdown', onPointerDown, {passive:false});
  canvas.addEventListener('pointermove', onPointerMove, {passive:false});
  canvas.addEventListener('pointerup', onPointerUp, {passive:true});
  canvas.addEventListener('pointercancel', onPointerUp, {passive:true});

  // iOS Safari sometimes prefers touch events; add fallback
  canvas.addEventListener('touchstart', (e)=>{ e.preventDefault(); onPointerDown(e); }, {passive:false});
  canvas.addEventListener('touchmove',  (e)=>{ e.preventDefault(); onPointerMove(e); }, {passive:false});
  canvas.addEventListener('touchend',   (e)=>{ e.preventDefault(); onPointerUp(e); }, {passive:false});

  // ===== Render helpers =====
  function draw() {
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    ctx.clearRect(0,0,w,h);

    // Background
    ctx.fillStyle = '#0b0f14';
    ctx.fillRect(0,0,w,h);

    // Layout: pseudo-3D cylinder as stacked ellipses
    const centerX = w * 0.5;
    const topY = h * 0.12;
    const bottomY = h * 0.90;
    const towerHeightPx = bottomY - topY;

    const radiusX = Math.min(w * 0.42, 260);
    const radiusY = radiusX * 0.22; // ellipse squash for 3D feel
    const levelStep = towerHeightPx / H;

    const rotIndex = getRotIndex();

    // Draw water (killzone) as a filled region from bottom up
    const killLine = Math.floor(killLevel);
    const waterY = bottomY - Math.min(H, Math.max(0, killLevel)) * levelStep;
    ctx.fillStyle = 'rgba(40,120,200,0.20)';
    ctx.fillRect(0, waterY, w, bottomY - waterY);

    // Draw levels from bottom to top for better overlap look
    for (let y=0; y<H; y++) {
      const py = bottomY - y * levelStep;
      const alpha = 0.12 + (y / H) * 0.18;
      ctx.strokeStyle = `rgba(180,200,220,${alpha})`;
      ctx.lineWidth = 1;

      // ellipse ring
      ctx.beginPath();
      ctx.ellipse(centerX, py, radiusX, radiusY, 0, 0, Math.PI*2);
      ctx.stroke();

      // draw occupied cells as small quads on the ring
      for (let s=0; s<N; s++) {
        if (!grid[y][s]) continue;

        // map sector to angle; rotate by rotFloat
        const ang = ((s - rotFloat) / N) * Math.PI * 2;
        const cx = centerX + Math.cos(ang) * radiusX;
        const cy = py + Math.sin(ang) * radiusY;

        // size: clamp by local arc spacing so adjacent sectors look "glued"
        const depth = (Math.sin(ang) + 1) * 0.5; // 0 back .. 1 front
        const sizeDepth = 10 + depth * 6;
        const ang2 = ((s + 1 - rotFloat) / N) * Math.PI * 2;
        const cx2 = centerX + Math.cos(ang2) * radiusX;
        const cy2 = py + Math.sin(ang2) * radiusY;
        const arcDist = Math.hypot(cx2 - cx, cy2 - cy);
        const size = Math.min(sizeDepth, Math.max(6, arcDist * 0.98));

        ctx.fillStyle = `rgba(230,230,240,${0.55 + depth*0.35})`;
        ctx.fillRect(cx - size/2, cy - size/2, size, size);
      }

      // highlight active/front sector line (only at few top levels to reduce clutter)
      if (y % 3 === 0) {
        const ang = ((rotIndex - rotFloat) / N) * Math.PI * 2;
        const x1 = centerX + Math.cos(ang) * (radiusX * 0.15);
        const y1 = py + Math.sin(ang) * (radiusY * 0.15);
        const x2 = centerX + Math.cos(ang) * (radiusX * 1.02);
        const y2 = py + Math.sin(ang) * (radiusY * 1.02);
        ctx.strokeStyle = 'rgba(255,210,120,0.35)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(x1,y1);
        ctx.lineTo(x2,y2);
        ctx.stroke();
      }
    }

    // Visual "drop line": the piece always falls on the tower axis.
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(centerX, topY);
    ctx.lineTo(centerX, bottomY);
    ctx.stroke();

    // Draw the active falling piece in SCREEN SPACE (always in the center “drop line”).
    // The cylinder rotation selects where it will land, but the piece itself does not
    // travel around the circumference while falling.
    if (activePiece) {
      const cells = activePiece.rotations[pieceRotIndex];
      // Center the shape around x=0 for rendering, so 2-block bars look “glued”.
      let minX = Infinity, maxX = -Infinity;
      for (const c of cells) { minX = Math.min(minX, c.x); maxX = Math.max(maxX, c.x); }
      const midX = (minX + maxX) * 0.5;

      const size = 14;
      const gap = 1.5;
      ctx.fillStyle = 'rgba(255,180,180,0.95)';

      for (const cell of cells) {
        const cyPiece = pieceY + cell.y;
        // allow drawing slightly outside the field so the entry is visible
        if (cyPiece < -3 || cyPiece > H + 3) continue;
        const localX = (cell.x - midX) * (size + gap);
        const cxPiece = centerX + localX;
        const cyPiecePx = bottomY - cyPiece * levelStep; // straight vertical fall
        if (cyPiecePx < topY - 80 || cyPiecePx > bottomY + 80) continue;
        ctx.fillRect(cxPiece - size/2, cyPiecePx - size/2, size, size);
      }
    }

    // HUD
    rightHud.textContent = `rotIndex=${rotIndex}  killLine=${killLine}/${H}`;
    leftHud.textContent = `N=${N}  H=${H}  rot=${rotFloat.toFixed(2)}`;
  }

  // ===== Update loop =====
  let lastT = performance.now();
  function tick() {
    const now = performance.now();
    const dt = Math.min(0.05, (now - lastT) / 1000);
    lastT = now;

    // update killzone
    killLevel += killRate * dt;
    if (killLevel >= H) {
      // simple game over reset for now
      killLevel = 0;
    }

    // update falling piece
    fallTimer += dt;
    if (fallTimer >= fallInterval) {
      fallTimer -= fallInterval;
      tryMoveDown();
    }

    // rotation inertia + snap
    if (!dragging) {
      // inertia
      rotFloat += rotVel * dt;

      // damping
      rotVel *= Math.exp(-friction * dt);

      // snap-to-sector when slow
      if (Math.abs(rotVel) < snapVelThreshold) {
        const target = Math.round(rotFloat);
        const diff = target - rotFloat;
        rotVel += diff * snapStrength * dt;

        if (Math.abs(diff) < snapEps && Math.abs(rotVel) < 0.05) {
          rotFloat = target;
          rotVel = 0;
        }
      }
    }

    draw();
    requestAnimationFrame(tick);
  }
  requestAnimationFrame(tick);

  // Start the first falling piece.
  spawnPiece();

})();
</script>
</body>
</html>