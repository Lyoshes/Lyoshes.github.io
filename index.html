<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Ring Tetris MVP</title>
  <style>
    html, body { margin:0; padding:0; height:100%; background:#0b0f14; overflow:hidden; touch-action:none; }
    canvas { display:block; width:100%; height:100%; }
    .hint { position:fixed; left:10px; bottom:10px; color:#9fb2c7; font:12px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial; opacity:.85; }
    .hud  { position:fixed; left:10px; top:10px; color:#cfe0f3; font:12px/1.3 system-ui, -apple-system, Segoe UI, Roboto, Arial; opacity:.9; }
  </style>
</head>
<body>
<canvas id="c"></canvas>
<div class="hud" id="hud"></div>
<div class="hint">Свайп влево/вправо: вращение цилиндра с инерцией. Фигура падает строго по центру; цилиндр «подставляет» сектор.</div>
<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const TAU = Math.PI * 2;

  // ===== Game params =====
  const N = 30;   // sectors around ring
  const H = 24;   // height in rows (0 bottom)
  const ANG_OFFSET = Math.PI / 2; // "front" is the bottom point (closest to user)

  // ===== Grid =====
  // grid[y][s] : 0 empty, 1 filled
  const grid = Array.from({length: H}, () => new Uint8Array(N));

  // ===== Pieces (MVP: single + bar2) =====
  const PIECES = [
    { name:'single', cells:[{x:0,y:0}] },
    { name:'bar2',   cells:[{x:0,y:0},{x:1,y:0}] },
  ];

  // Active falling piece state (falls in screen-space center)
  let activePiece = null;
  let pieceY = H + 3;       // float (grid coords), decreases to 0
  let fallTimer = 0;
  let fallInterval = 0.45;   // seconds per row (faster)

  // ===== Killzone (visual only for now) =====
  let killLevel = 0;
  let killRate  = 0.18;     // rows per second

  // ===== Rotation (cylinder) =====
  let rotFloat  = 0;        // continuous sectors
  let targetRot = 0;
  let rotVel    = 0;        // sectors/sec

  const DAMP = 9.0;         // velocity damping
  const SPRING = 35.0;      // pull to target

  // ===== Input (drag like iOS picker) =====
  // Hold the cylinder, drag left/right: it steps through sectors one by one (no inertia).
  let dragging = false;
  let startX = 0;
  let startRot = 0;
  let lastStep = 0;

  const PX_PER_STEP = 34;        // smaller => more sensitive (like iOS picker)
  const DEADZONE_PX = 6;

  canvas.addEventListener('pointerdown', (e) => {
    dragging = true;
    startX = e.clientX;
    startRot = targetRot;  // integer sector baseline
    lastStep = 0;
    rotVel = 0;
    canvas.setPointerCapture(e.pointerId);
  });

  canvas.addEventListener('pointermove', (e) => {
    if (!dragging) return;
    const dx = e.clientX - startX;
    if (Math.abs(dx) < DEADZONE_PX) return;

    // Positive dx => drag right => increase sector index (turn right)
    const step = Math.trunc(dx / PX_PER_STEP);

    if (step !== lastStep) {
      lastStep = step;
      targetRot = startRot + step; // integer stepping
      rotFloat = targetRot;        // immediate snap
      rotVel = 0;
    }
  });

  canvas.addEventListener('pointerup', (e) => {
    if (!dragging) return;
    dragging = false;
    canvas.releasePointerCapture(e.pointerId);
    // already snapped during drag; nothing else to do
  });

  function normSector(s) {
    s %= N;
    if (s < 0) s += N;
    return s;
  }

  function snappedRot() {
    return normSector(Math.round(rotFloat));
  }

  // ===== Spawn / collision / lock =====
  function spawnPiece() {
    activePiece = PIECES[(Math.random() * PIECES.length) | 0];
    // start above top
    pieceY = H + 3;
    fallTimer = 0;
  }

  function canPlaceAt(y) {
    if (!activePiece) return false;
    const s0 = snappedRot(); // IMPORTANT: cylinder decides landing sector
    for (const c of activePiece.cells) {
      const cy = y + c.y;
      const cs = normSector(s0 + c.x);
      if (cy < 0) return false;
      if (cy >= H) continue; // above field is ok
      if (grid[cy][cs]) return false;
    }
    return true;
  }

  function computeGhostY() {
    if (!activePiece) return null;
    let y = Math.floor(pieceY);
    while (canPlaceAt(y - 1)) y -= 1;
    return y;
  }

  function lockPiece() {
    if (!activePiece) return;

    // ===== CRITICAL FIX 1: snap rotation BEFORE writing to grid =====
    const s0 = snappedRot();
    rotFloat = s0;
    targetRot = s0;
    rotVel = 0;

    // write cells
    for (const c of activePiece.cells) {
      const cy = Math.floor(pieceY) + c.y;
      const cs = normSector(s0 + c.x);
      if (cy >= 0 && cy < H) grid[cy][cs] = 1;
    }

    clearRings();

    // If piece locked above visible area -> reset (simple MVP)
    // Spawn next
    spawnPiece();
  }

  function clearRings() {
    for (let y = 0; y < H; y++) {
      let full = true;
      for (let s = 0; s < N; s++) {
        if (!grid[y][s]) { full = false; break; }
      }
      if (!full) continue;

      // drop everything above down
      for (let yy = y; yy < H - 1; yy++) {
        grid[yy].set(grid[yy + 1]);
      }
      grid[H - 1].fill(0);

      y--; // re-check same row

      // reward: push back killzone a bit
      killLevel = Math.max(0, killLevel - 1.0);
    }
  }

  function tryMoveDown() {
    const nextY = Math.floor(pieceY) - 1;
    if (canPlaceAt(nextY)) {
      pieceY = nextY;
    } else {
      lockPiece();
    }
  }

  // ===== Rendering helpers =====
  function resize() {
    const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
    const w = Math.floor(canvas.clientWidth * dpr);
    const h = Math.floor(canvas.clientHeight * dpr);
    if (canvas.width !== w || canvas.height !== h) {
      canvas.width = w;
      canvas.height = h;
      ctx.setTransform(dpr,0,0,dpr,0,0); // keep coordinates in CSS pixels
    }
  }

  function levelYToScreenY(topY, towerHeightPx, y) {
    // y=0 bottom, y=H top
    const t = 1 - (y / H);
    return topY + t * towerHeightPx;
  }

  function sectorCenterXY(centerX, yScreen, radiusX, radiusY, s, rot) {
    const ang = ((s - rot) / N) * TAU + ANG_OFFSET;
    return {
      x: centerX + Math.cos(ang) * radiusX,
      y: yScreen + Math.sin(ang) * radiusY,
      ang,
    };
  }

  function drawOrientedBlock(px, py, tx, ty, w, h, fillStyle, alpha=1) {
    ctx.save();
    ctx.translate(px, py);
    const a = Math.atan2(ty, tx);
    ctx.rotate(a);
    ctx.globalAlpha = alpha;
    ctx.fillStyle = fillStyle;
    ctx.fillRect(-w/2, -h/2, w, h);
    ctx.restore();
    ctx.globalAlpha = 1;
  }

  function draw() {
    resize();
    const w = canvas.clientWidth;
    const h = canvas.clientHeight;
    ctx.clearRect(0,0,w,h);

    // Background
    ctx.fillStyle = '#0b0f14';
    ctx.fillRect(0,0,w,h);

    // Layout cylinder
    const centerX = w * 0.5;
    const topY = h * 0.10;
    const bottomY = h * 0.92;
    const towerHeightPx = bottomY - topY;

    const radiusX = Math.min(w * 0.38, 260);
    const radiusY = radiusX * 0.28;

    // Water / killzone
    const killY = levelYToScreenY(topY, towerHeightPx, killLevel);
    ctx.fillStyle = 'rgba(28,72,120,0.42)';
    ctx.fillRect(0, killY, w, h - killY);

    // Rings (level ellipses)
    ctx.strokeStyle = 'rgba(160,190,220,0.25)';
    ctx.lineWidth = 1;
    for (let y=0; y<=H; y++) {
      const py = levelYToScreenY(topY, towerHeightPx, y);
      ctx.beginPath();
      ctx.ellipse(centerX, py, radiusX, radiusY, 0, 0, TAU);
      ctx.stroke();
    }

    // Center drop-line (visual)
    ctx.strokeStyle = 'rgba(255,220,140,0.55)';
    ctx.beginPath();
    ctx.moveTo(centerX, topY);
    ctx.lineTo(centerX, bottomY);
    ctx.stroke();

    // ===== Fixed blocks =====
    // draw back-to-front by painter's algorithm: use sin(angle) as depth proxy
    const blocks = [];
    for (let y=0; y<H; y++) {
      const yScr = levelYToScreenY(topY, towerHeightPx, y + 0.5);
      for (let s=0; s<N; s++) {
        if (!grid[y][s]) continue;
        const p = sectorCenterXY(centerX, yScr, radiusX, radiusY, s, rotFloat);
        blocks.push({y, s, yScr, p});
      }
    }
    blocks.sort((a,b) => (a.p.y - b.p.y)); // farther (top) first, closer (bottom) last

    for (const b of blocks) {
      const p0 = b.p;
      // neighbor points to estimate tangent and width
      const p1 = sectorCenterXY(centerX, b.yScr, radiusX, radiusY, b.s+1, rotFloat);
      const p_1 = sectorCenterXY(centerX, b.yScr, radiusX, radiusY, b.s-1, rotFloat);
      const tx = (p1.x - p_1.x);
      const ty = (p1.y - p_1.y);
      const arcDist = Math.hypot(p1.x - p0.x, p1.y - p0.y);

      // ===== CRITICAL FIX 2: exact-ish sector width + tiny overlap =====
      const bw = arcDist * 1.06; // overlap kills anti-alias seams
      const bh = (towerHeightPx / H) * 0.90;

      drawOrientedBlock(p0.x, p0.y, tx, ty, bw, bh, 'rgba(235,240,250,0.55)', 1);
    }

    // ===== Ghost projection (landing position) =====
    // Render ghost in cylinder-space (same projection as locked blocks),
    // but use a SNAPPED rotation so the front sector is perfectly aligned to the drop-line.
    if (activePiece) {
      const ghostY = computeGhostY();
      if (ghostY !== null) {
        const s0 = snappedRot();
        const rotSnap = s0; // integer rotation => exact alignment

        const ghostCells = [];
        for (const c of activePiece.cells) {
          const cy = ghostY + c.y;
          const cs = normSector(s0 + c.x);
          if (cy < 0 || cy >= H) continue;

          const yScr = levelYToScreenY(topY, towerHeightPx, cy + 0.5);
          const p0 = sectorCenterXY(centerX, yScr, radiusX, radiusY, cs, rotSnap);
          ghostCells.push({cy, cs, yScr, p0});
        }

        ghostCells.sort((a,b) => (a.p0.y - b.p0.y));

        for (const g of ghostCells) {
          const p0 = g.p0;
          const p1 = sectorCenterXY(centerX, g.yScr, radiusX, radiusY, g.cs + 1, rotSnap);
          const p_1 = sectorCenterXY(centerX, g.yScr, radiusX, radiusY, g.cs - 1, rotSnap);
          const tx = (p1.x - p_1.x);
          const ty = (p1.y - p_1.y);
          const arcDist = Math.hypot(p1.x - p0.x, p1.y - p0.y);

          const bw = arcDist * 1.06;
          const bh = (towerHeightPx / H) * 0.90;

          drawOrientedBlock(p0.x, p0.y, tx, ty, bw, bh, 'rgba(110,255,150,0.28)', 1);
        }
      }
    }



    // ===== Active falling piece =====
    // IMPORTANT: draw using the SAME sector projection as the ghost / final placement,
    // but still "falls straight down" (x for each cell is constant over time).
    if (activePiece) {
      const s0 = snappedRot();
      const rotSnap = s0; // integer rotation => exact alignment of the front sector

      // Use block size at current piece height
      const yScrRef = levelYToScreenY(topY, towerHeightPx, (pieceY) + 0.5);
      const p0 = sectorCenterXY(centerX, yScrRef, radiusX, radiusY, s0, rotSnap);
      const p1 = sectorCenterXY(centerX, yScrRef, radiusX, radiusY, s0 + 1, rotSnap);
      const arcDist = Math.hypot(p1.x - p0.x, p1.y - p0.y);

      const bw = arcDist * 1.06;
      const bh = (towerHeightPx / H) * 0.90;

      ctx.fillStyle = 'rgba(255,170,180,0.75)';
      for (const c of activePiece.cells) {
        const cs = normSector(s0 + c.x);
        const cy = pieceY + c.y;

        const yScr = levelYToScreenY(topY, towerHeightPx, cy + 0.5);
        const pc = sectorCenterXY(centerX, yScr, radiusX, radiusY, cs, rotSnap);

        // draw as axis-aligned rect (same look as before), but at projected x/y
        ctx.fillRect(pc.x - bw/2, pc.y - bh/2, bw, bh);
      }
    }


    // HUD
    document.getElementById('hud').textContent =
      `N=${N} H=${H} rot=${rotFloat.toFixed(2)} (snap=${snappedRot()})  kill=${killLevel.toFixed(1)}/${H}`;
  }

  // ===== Main loop =====
  let last = performance.now();
  function tick(now) {
    const dt = Math.min(0.05, Math.max(0.001, (now - last) / 1000));
    last = now;

    // killzone
    killLevel += killRate * dt;
    if (killLevel >= H) {
      // simple reset
      for (let y=0; y<H; y++) grid[y].fill(0);
      killLevel = 0;
      rotFloat = targetRot = 0;
      rotVel = 0;
      spawnPiece();
    }

    // rotation: picker-like discrete stepping (no inertia)
    rotFloat = targetRot;
    // keep rotFloat bounded to avoid float growth
    if (rotFloat >  1e6) rotFloat %= N;
    if (rotFloat < -1e6) rotFloat %= N;

    // falling
    fallTimer += dt;
    if (fallTimer >= fallInterval) {
      fallTimer -= fallInterval;
      tryMoveDown();
    }

    draw();
    requestAnimationFrame(tick);
  }

  spawnPiece();
  requestAnimationFrame(tick);
})();
</script>
</body>
</html>
